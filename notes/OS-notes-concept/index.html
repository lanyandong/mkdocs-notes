<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="ydlan">
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>知识笔记-操作系统-基础概念 - Learning Notes</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u77e5\u8bc6\u7b14\u8bb0-\u64cd\u4f5c\u7cfb\u7edf-\u57fa\u7840\u6982\u5ff5";
    var mkdocs_page_input_path = "notes\\OS-notes-concept.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Learning Notes</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../..">主页</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">面试知识</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../OS-notes-keynote/">面试要点-操作系统篇</a>
                </li>
                <li class="">
                    
    <a class="" href="../computer-network-keynote/">面试要点-计算机网络篇</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">数据结构和算法</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../datastructure-algorithm/algorithm-analysis/">算法-复杂度分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../datastructure-algorithm/sort-algorithm/">算法-排序-总结</a>
                </li>
                <li class="">
                    
    <a class="" href="../datastructure-algorithm/simplesort/">算法-排序-简单排序</a>
                </li>
                <li class="">
                    
    <a class="" href="../datastructure-algorithm/mergesort/">算法-排序-归并排序</a>
                </li>
                <li class="">
                    
    <a class="" href="../datastructure-algorithm/shellsort/">算法-排序-Shell排序</a>
                </li>
                <li class="">
                    
    <a class="" href="../datastructure-algorithm/quicksort/">算法-排序-快速排序</a>
                </li>
                <li class="">
                    
    <a class="" href="../datastructure-algorithm/redixsort/">算法-排序-基数算法</a>
                </li>
                <li class="">
                    
    <a class="" href="../datastructure-algorithm/recursion/">算法-递归算法</a>
                </li>
                <li class="">
                    
    <a class="" href="../datastructure-algorithm/stack-queue/">数据结构-栈和队列</a>
                </li>
                <li class="">
                    
    <a class="" href="../datastructure-algorithm/linklist/">数据结构-链表</a>
                </li>
                <li class="">
                    
    <a class="" href="../datastructure-algorithm/tree/">数据结构-树</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">知识笔记</span>
    <ul class="subnav">
                <li class=" current">
                    
    <a class="current" href="./">知识笔记-操作系统-基础概念</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#_1">操作系统结构</a></li>
    

    <li class="toctree-l3"><a href="#process">Process 进程</a></li>
    

    <li class="toctree-l3"><a href="#threads">Threads 线程</a></li>
    

    <li class="toctree-l3"><a href="#cpu-scheduling">CPU Scheduling</a></li>
    

    <li class="toctree-l3"><a href="#process-synchronization">Process Synchronization</a></li>
    

    <li class="toctree-l3"><a href="#deadlock">Deadlock</a></li>
    

    <li class="toctree-l3"><a href="#memory-management">Memory  management</a></li>
    

    <li class="toctree-l3"><a href="#virtual-memory">Virtual memory</a></li>
    

    <li class="toctree-l3"><a href="#file-system">File system</a></li>
    

    <li class="toctree-l3"><a href="#io-system">I/O System</a></li>
    

    <li class="toctree-l3"><a href="#disk">Disk 磁盘</a></li>
    

    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../computer-network/">知识笔记-计算机网络-基础概念</a>
                </li>
                <li class="">
                    
    <a class="" href="../computer-design/">知识笔记-组成原理-基础概念</a>
                </li>
                <li class="">
                    
    <a class="" href="../system-structure/">知识笔记-系统结构-基础概念</a>
                </li>
                <li class="">
                    
    <a class="" href="../software-engineering/">知识笔记-软件工程-基础概念</a>
                </li>
                <li class="">
                    
    <a class="" href="../computer-introduction/">知识笔记-计算机基础-常用概念</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">编程语言</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../language/java/java-collection/">Java程序设计-容器类库</a>
                </li>
                <li class="">
                    
    <a class="" href="../language/java/java-super-this/">Java程序设计-关键字this和super</a>
                </li>
                <li class="">
                    
    <a class="" href="../language/java/java-multithreading/">Java程序设计-多线程基础</a>
                </li>
                <li class="">
                    
    <a class="" href="../language/java/java-jdbc/">Java程序设计-jdbc的使用.md</a>
                </li>
                <li class="">
                    
    <a class="" href="../language/cpp-base-concept/">编程语言-C++常用基础概念</a>
                </li>
                <li class="">
                    
    <a class="" href="../language/optimized-cpp/">编程语言-C++性能优化指南</a>
                </li>
                <li class="">
                    
    <a class="" href="../language/python/">编程语言-Python编程基础</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../about/">其他</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Learning Notes</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>知识笔记 &raquo;</li>
        
      
    
    <li>知识笔记-操作系统-基础概念</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/ydlan/mkdocs-notes/edit/master/docs/notes/OS-notes-concept.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="_1">操作系统结构</h2>
<p><strong>操作系统</strong></p>
<p>是一组控制和管理计算机软硬件资源，合理地对各类作业进行调度及方便用户使用的程序集合，是计算机的第一层软件。</p>
<p><strong>系统结构</strong></p>
<ul>
<li>简单结构</li>
<li>模块化结构</li>
<li>层次结构</li>
<li>微内核结构</li>
</ul>
<p><strong>启动过程</strong></p>
<ol>
<li>打开电源</li>
<li>CPU通过系统时钟初始化</li>
<li>在BIOS中找到启动程序的CPU的第一条指令</li>
<li>执行开机自检(POST)，检查所有硬件设备</li>
</ol>
<p><strong>I/O操作</strong></p>
<p>IO设备可以和CPU同时执行
- I/O在设备和控制器缓存（controller's buffer）之间转移数据
- CPU在控制器和主存之间转移数据。</p>
<p>I/O设备访问
- Memory Mapped I/O（CPU就像访问内存一样访问I/O）
- Programmed I/O（每个控制寄存器都分配一个I/O端口号，CPU使用特定的I/O指令去读写寄存器）。</p>
<p><strong>操作系统的服务</strong></p>
<ul>
<li>程序执行 Program execution</li>
<li>I/O操作 I/O operations</li>
<li>文件系统的操作 File-system manipulation</li>
<li>Communications 在进程间传递消息</li>
<li>
<p>错误检测 Error detection</p>
</li>
<li>
<p>资源分配 Resource allocation</p>
</li>
<li>账号管理 Accounting </li>
<li>保护 Protection</li>
</ul>
<p><strong>系统组件</strong></p>
<ul>
<li><strong>Process Management</strong></li>
<li><strong>Memory Management</strong></li>
<li><strong>File Management</strong></li>
<li><strong>I/O System Management</strong></li>
<li><strong>Secondary Management</strong></li>
<li>Networking</li>
<li>Protection System</li>
<li>Command-Interpreter System</li>
</ul>
<hr />
<h2 id="process">Process 进程</h2>
<p><strong>进程 Process</strong></p>
<p>a program in execution一个执行过程中的程序，是资源分配的单位。</p>
<ul>
<li>Program（executable）：磁盘上的passive实体</li>
<li>Process：active entity被激活的实体，包含程序计数器、栈、堆、文本、数据。</li>
</ul>
<p><strong>程序 Program</strong></p>
<p>一个程序包含Code、Data、DLLs 动态链接库、mapped files。</p>
<p><strong>Process vs Program</strong></p>
<ul>
<li>
<p>两个进程可能和同一个程序相关联</p>
</li>
<li>
<p>两条单独执行的顺序</p>
</li>
<li>文本部分相同，数据、堆、栈都不同</li>
</ul>
<p><strong>进程状态</strong></p>
<ul>
<li>running：指令正在执行</li>
<li>waiting：进程等待某个事件发生</li>
<li>
<p>ready：进程等待分配给CPU</p>
</li>
<li>
<p>new：进程被创建</p>
</li>
<li>terminated：进程结束执行</li>
</ul>
<p><img alt="process states" src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1474977550,2975918179&amp;fm=26&amp;gp=0.jpg" /></p>
<p><strong>进程控制块（PCB）</strong></p>
<p>和每个进程相关联的信息，包含：</p>
<ul>
<li>Process state 进程状态</li>
<li>Program counter 程序计数器</li>
<li>CPU register 寄存器：为了能让CPU离开进程后回来还能执行</li>
<li>CPU scheduling information CPU调度信息</li>
<li>Memory-management information 内存管理信息</li>
</ul>
<p><strong>进程调度</strong></p>
<ul>
<li>长程调度Long-term scheduling(or job scheduling)：从job queue中选一个到ready queue中,内存可用时,从磁盘中移出一个到内存。</li>
<li>短程调度Short-term scheduling(or CPU scheduling)：从ready queue中选一个到running，内存到执行。</li>
<li>中程调度(Medium-term scheduling)：CPU和内存资源管理的混合</li>
<li>中断处理(Interrupt handling)：从waiting到ready</li>
</ul>
<p><strong>进程通信</strong></p>
<ul>
<li><strong>shared memory</strong> 共享内存</li>
<li><strong>message passing</strong> 消息传递</li>
</ul>
<hr />
<h2 id="threads">Threads 线程</h2>
<p>进程是资源的拥有者，线程用来调度任务，是CPU的调度单位。</p>
<ul>
<li>独立的 PC, Register, Stack pointer</li>
<li>共享的 Code, Data, File</li>
</ul>
<p><img alt="thread" src="https://s2.ax1x.com/2019/07/31/eNrmO1.md.png" /></p>
<p><strong>两类线程</strong></p>
<ul>
<li>用户级线程，所有线程在user space中完成</li>
<li>核心级线程，OS直接执行</li>
</ul>
<p><strong>多线程编程</strong></p>
<p>响应度高，资源共享，能够充分利用多处理器体系结构。包括了多对一，一对一，多对多线程模型。</p>
<hr />
<h2 id="cpu-scheduling">CPU Scheduling</h2>
<p><strong>调度类型</strong></p>
<ul>
<li>非抢占式 ：1.从running到waiting，2.Terminates</li>
<li>抢占式：1.从waiting到ready，2.从running到ready</li>
</ul>
<p><strong>如何调度</strong></p>
<ol>
<li>切换上下文</li>
<li>转换为use mode</li>
<li>跳转到用户程序中的适当位置来重启程序</li>
</ol>
<p><strong>Scheduling criteria 性能指标</strong></p>
<ul>
<li>Max CPU utilization——让CPU越忙越好</li>
<li>Max Throughput——单位时间内能完成的进程个数越多越好</li>
<li>Min Turnround time——周转时间越短越好</li>
<li>Min Waiting time——等待时间</li>
<li>Min Response time——响应时间指从请求提交到第一个相应产生，并非输出产生</li>
</ul>
<p><strong>常用调度算法</strong></p>
<ul>
<li><strong>FCFS（First-Come, First-Served ）</strong>：FCFS最简单，是非抢占式的，进程按照请求CPU的顺序排序。</li>
<li><strong>SJF（Shortest Job First）</strong>：也是非抢占式的，如果运行时间事先已知，可以每次挑选最短的任务以避免小进程等待大进程释放的情况。SJF最优是可以证明的。但是难以得知下次CPU请求的长度，只能预测。一般通过数学期望 <span><span class="MathJax_Preview">t_{n+1}=at_{n}+(1-a)t_{n}</span><script type="math/tex">t_{n+1}=at_{n}+(1-a)t_{n}</script></span> 来确定。</li>
<li><strong>Priority（Priority Scheduling）</strong>：可以是抢占式的，也可以是非抢占式的，优先级最高的进程被选出来运行。最大的问题是可能会出现无限等待或starvation，优先级低的可能永远无法运行。可以使用老化(aging)进行解决，即每执行一个周期就把当前进程优先级降一下。</li>
<li><strong>RR （Round-Robin Scheduling）</strong>：先给定时间片（time quantum）的大小。Case 1: CPU burst &lt;= one time quantum，执行完就退出执行其他任务；Case 2: CPU burst &gt; one time quantum，执行不完将该任务放到队尾。</li>
</ul>
<hr />
<h2 id="process-synchronization">Process Synchronization</h2>
<p><strong>临界区问题</strong></p>
<p>每个进程拥有的操作共享数据的代码称为<code>critical section 临界区</code>。要保证当一个进程执行时它的临界区代码时，其他进程不能执行临界区代码。</p>
<p>解决方案：在执行之前加点条件，判断能否执行，执行完毕后解锁.</p>
<pre><code class="c">do{
    entry section   //执行前判断
        crical section
    exit section    //执行完毕后解锁
        reminder section
}
</code></pre>

<p>解决临界区问题需要满足</p>
<ul>
<li>
<p>Mutual Exclusion  互斥</p>
</li>
<li>
<p>Progress  前进原则,如果没有临界区代码在执行，有一个进程想进入临界区是，应当允许</p>
</li>
<li>
<p>Bounded wait 有限等待,想进入临界区的在有限时间内总能进入。</p>
</li>
</ul>
<p><strong>信号量Semaphores </strong></p>
<p>信号量 一个整形变量，只能通过两个标准原子操作：<code>wait()，signal()</code>。</p>
<pre><code class="c">// wait(s):
while(s&lt;=0)
;   //no-operation
s--;

//signal(s):
s++
</code></pre>

<p>在wait()和signal()操作中，对信号量的修改必须是原子的，即当一个进程修改信号量值时，不能有其他进程同时修改同一信号的值。</p>
<pre><code class="c">//初始化：int matex=1; 
do {
    wait(mutex);
    //critical section
    signal(mutex);
    //remainder section
} while(1);
</code></pre>

<p><strong>信号量实现</strong></p>
<p>主要缺点是忙等待，即当一个进程位于其临界区内时，其他想进入临界区的进程必须连续循环等待，浪费了CPU时钟。也称为自旋锁。为了克服忙等待，可以使用阻塞并放入等待队列的操作。通过wakeup()来重新执行。</p>
<pre><code class="c">//定义一个新结构
typedef struct {
    int value;
    struct process *List;
} semaphore;

//新的信号量操作定义
wait(semaphore *S){
    S.value--;
    if(S.value&lt;0) {
        block();    //add this process to S.List
    }
}

signal(semaphore *S) {
    S.value++;
    if(S.value&lt;=0) {
        wakeup(P);  //remove a process P from S.List
    }
}
</code></pre>

<p><strong>读写者问题</strong></p>
<ol>
<li>写者、读者互斥访问文件资源。</li>
<li>多个读者可以同时访问文件资源。</li>
<li>只允许一个写者访问文件资源。</li>
</ol>
<p><strong>读者优先</strong></p>
<ul>
<li>没有读者会因为有一个写者在等待而去等待其他读者的完成</li>
<li>写者执行写操作前，应该让所有读者和写者退出</li>
<li>除非有一个写者在访问临界区，其他情况下，读者不应该等待</li>
</ul>
<pre><code class="c">//初始化变量
BINARY_SEMAPHORE wrt=1;
BINARY_SEMAPHORE mutex=1;
int readcount=0;

//Reader:
do {
    wait(mutex);      //Allow 1 reader in entry
    readcount=readcount+1;
    if(readcount==1)
        wait(wrt);    //1st reader locks writer
    signal(mutex);
        //reading operation
    wait(mutex);
    readcount=readcount-1;
    if(readcount==0)
        signal(wrt);    //last reader frees writer
    signal(mutex);
}

//Writer:
do {
    wait(wrt);
        //writing operation
    signal(wrt);
}
</code></pre>

<p><strong>写者优先</strong></p>
<p>如果一个写者等待访问对象，那么不会有新读者开始读操作。</p>
<pre><code class="c">//初始化变量
BINARY_SEMAPHORE read=1;    //使有写者进行操作时读者等待
BINARY_SEMAPHORE file=1;    //使文件操作互斥
BINARY_SEMAPHORE mutex1=1;  //使改变readcount的方法互斥
BINARY_SEMAPHORE mutex2=1;  //使改变writecount的方法互斥
int readcount=0;
int writecount=0;

//Reader:
do {
    wait(read);         //等待直至读者队列没有阻塞，即全部写者都退出，同时自身进入后再次上锁，使后来的读者等待，因为接下来要进行一系列互斥的操作
    wait(mutex1);
    readcount++;
    if(readcount==1)    //第一个读者进入
        wait(file);     //后来的写者无法操作文件，但对后来的读者的文件操作不造成影响
    signal(mutex1);
    signal(read);       //释放
        //read operation
    wait(mutex1);
    readcount--;
    if(readcount==0)
        signal(file);
    signal(mutex1);
}

//Writer:
do {
    wait(mutex2);
    writecount++;
    if(writecount==1)   //第一个写者进入
        wait(read);     //阻塞读者队列
    signal(mutex2);
    wait(file);
        //write operation
    signal(file);
    wait(mutex2);
    writecount--;
    if(writecount==0)   //最后一个写者退出
        signal(read);   //释放读者队列
    signal(mutex2);
}

</code></pre>

<p><strong>哲学家进餐问题</strong></p>
<p>5个哲学家围着桌子吃饭，筷子只有5枝，分别在每个哲学家的左手边和右手边。哲学家必须得到两只筷子才能吃饭，要使每个哲学家都能吃到饭，该如何调度。</p>
<pre><code class="java">// 管程实现
void philosopher(int i) {   //主方法
    while(true) {
        thinking();
        dp.pickup(i);
        eating();
        dp.putdown(i);
    }
}

monitor dp {
    enum{thinking,hungry,eating} state[5];
    condition self[5];
    void pickup(int i) {
        state[i]=hungry;    //设置本人为饥饿状态
        test[i];            //测试左右两个人是否在吃
        if(state[i]!=eating)//如果需要等待
            self[i].wait(); //进入等待，在pickup方法处阻塞
    }
    void putdown(int i) {
        state[i]=thinking;
        test((i+4)%5);      
        test((i+1)%5);      //本人放下筷子后，状态发生了变化，测试左右两个是否等待吃，如有，则给他们开始吃的机会（但也不一定能马上开始吃）
    }
    void test(int i) {
        if((state[(i+4)%5]!=eating) &amp;&amp; (state[i]==hungry) &amp;&amp; (state[(i+1)%5]!=eating)) {     //如果左右两个人并没有在吃，而且自己处于饥饿状态
            state[i]=eating;    //设置状态为eating
            self[i].signal();   //释放pickup方法，在philosopher方法中下一步将执行eating操作
        }
    }
    initializationCode() {
        for(int i=0;i&lt;5;i++)
            state[i]=thinking;
    }
}
</code></pre>

<p><strong>生产者消费者问题</strong></p>
<p>一个生产者，一个消费者，库存有限，如何能持续生产？解决方法：对于生产者，如果缓存是满的就去睡觉。消费者从缓存中取走数据后就叫醒生产者，让它再次将缓存填满。若消费者发现缓存是空的，就去睡觉了。下一轮中生产者将数据写入后就叫醒消费者。</p>
<p><strong>伪代码</strong></p>
<pre><code class="c">// 初始化变量：
semaphore mutex=1; //临界区互斥信号量
semaphore empty=n;  //空闲库存空间
semaphore full=0;  //库存初始化为空


//生产者进程：
producer ()
{
    while(1)
    {
        produce an item in nextp;  //生产数据
        P(empty);  //获取空闲库存单元
        P(mutex);  //进入临界区.
        add nextp to buffer;  //将数据放入缓冲区
        V(mutex);  //离开临界区,释放互斥信号量
        V(full);  //库存数加1
    }
}

//消费者进程：
consumer ()
{
    while(1)
    {
        P(full);  //获取库存数单元
        P(mutex);  // 进入临界区
        remove an item from buffer;  //从库存中取出数据
        V (mutex);  //离开临界区，释放互斥信号量
        V (empty) ;  //空闲库存数加1
        consume the item;  //消费数据
    }
}

</code></pre>

<hr />
<h2 id="deadlock">Deadlock</h2>
<p><strong>死锁的必要条件</strong></p>
<ul>
<li>Mutual exclusion 互斥访问</li>
<li>Hold and wait 占有和等待</li>
<li>No preemption 非抢占</li>
<li>Circular wait 循环等待</li>
</ul>
<p><strong>处理死锁的方法</strong>：忽略，预防，避免，检测恢复</p>
<p><strong>死锁预防</strong>：使死锁条件不成立。</p>
<ol>
<li>
<p>打破互斥，不是所有的资源都行</p>
</li>
<li>
<p>打破Hold and wait，在运行前把所有所需资源拿来（不容易），请求资源时把占有的资源都释放（很好）。</p>
</li>
<li>
<p>打破非抢占，不可能</p>
</li>
<li>
<p>打破循环等待，和hold and wait类似，有序的 资源访问。</p>
</li>
</ol>
<p><strong>死锁避免</strong>：判断请求在未来是否出现死锁（Banker's Algorithm 银行家算法）</p>
<ul>
<li>
<p>每个新进程必须声明它所需每种资源的最大实例数</p>
</li>
<li>
<p>进程请求时，系统必须确认是否分配资源会让系统不安全</p>
</li>
<li>
<p>当一个进程得到所有所需资源后，它必须在有限时间内归还</p>
</li>
</ul>
<p><strong>死锁检测</strong></p>
<ul>
<li>等待图：每种资源类型只有单个实例的情况</li>
<li>与银行家算法类似的检测算法：每种资源类型可有多个实例的情况。</li>
</ul>
<p><strong>死锁恢复</strong></p>
<ul>
<li>终止所有死锁进程</li>
<li>一次只终止一个进程，知道取消死锁循环为止</li>
</ul>
<hr />
<h2 id="memory-management">Memory  management</h2>
<p><strong>存储类型</strong></p>
<ul>
<li>Main memory 主存</li>
<li>Secondary storage 辅存</li>
</ul>
<p><strong>地址表示</strong></p>
<ul>
<li>逻辑地址（Logical address）： CPU生成 也叫Virtual address</li>
<li>物理地址（Physical address） ：实际在内存中的地址</li>
</ul>
<p><strong>内存分配</strong></p>
<ul>
<li>首次适应First-fit：分配按地址顺序的第一个可用的hole</li>
<li>最佳适应Best-fit：放到最小的足够大的hole</li>
<li>最差适应Worst-fit：放到最大的hole</li>
</ul>
<p>First-fit通常比Best-fit好，First-fit和Best-fit通常比Worst-fit好</p>
<p><strong>外部碎片</strong></p>
<p>不同进程间还未分配出去的小内存空间，单个碎片无法分配给任何一个进程。外部碎片存在于可变分区、段式虚拟存储系统(分段存储 Segmentation)中，主要是可变分区。</p>
<p><strong>内部碎片</strong></p>
<p>已经被分配出去的大于请求所需的内存空间部分，在固定分区中表现为分区内进程未使用的内存空间。无法重新利用，只能被浪费。内部碎片存在于固定分区、页式虚拟存储系统（分页存储 Paging)中，主要是固定分区。</p>
<p><strong>Paging 分页</strong></p>
<ul>
<li>把物理内存分为大小相等的块，称为<strong>Frame（帧）</strong></li>
<li>把逻辑内存分为大小相等的块，称为<strong>Page（页）</strong> 页的大小和帧相同</li>
<li>追踪所有空闲帧，必要时可以找到n个空闲帧加载进程</li>
<li>建立 <strong>Page table（页表）</strong> 记录Page和Frame的映射 页表的数据列只有一列</li>
</ul>
<p>CPU产生的地址被分为<Page number(p) +Page offset(d)></p>
<p><strong>分页的特点</strong></p>
<ul>
<li>清楚划分物理地址和逻辑地址</li>
<li>动态重定位</li>
<li>没有外部碎片，但会有一些内部碎片（最后一页）</li>
<li>Page大小通常在4KB-8KB</li>
</ul>
<p><strong>TLB</strong></p>
<p>一种支持并行搜索的高速硬件，先在TLB里面查，如果页号在里面，就取出相应的帧号，如果不在再去内存的页表找。</p>
<p><img alt="TLB" src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike150%2C5%2C5%2C150%2C50/sign=354cef9bfd1f4134f43a0d2c4476feaf/dcc451da81cb39db25af152ed0160924ab18305e.jpg" /></p>
<p><strong>分段</strong></p>
<p>分为大小不同的段，用来存一组相对完整的逻辑信息，逻辑地址包含 <strong>&lt;段号，偏移&gt;</strong></p>
<p><strong>段表</strong></p>
<ul>
<li>Segment-table base register(STBR) 指向段表起始位置  </li>
<li>Segment-table length register(STLR) 指明段数量</li>
</ul>
<hr />
<h2 id="virtual-memory">Virtual memory</h2>
<p><strong>虚拟内存</strong>：将用户逻辑内存从物理内存分离</p>
<ul>
<li>只有部分程序需要在内存中执行</li>
<li>因此逻辑内存空间可以比内存空间大很多</li>
<li>允许地址空间被多个进程共享</li>
</ul>
<p><strong>按需分页</strong>：当需要的时候才把页放入内存</p>
<p><strong>页面置换</strong></p>
<ol>
<li>在磁盘上找到需要的页的位置</li>
<li>在内存上找到空闲帧</li>
<li>如果没有，放一个牺牲帧到磁盘</li>
<li>将页放入空闲帧，更新页表</li>
</ol>
<p><strong>页置换算法</strong></p>
<ul>
<li>FIFO：先进先出</li>
<li>OPT：置换最长时间不会使用的页</li>
<li>LRU：置换最近最少从访问的页</li>
<li>Clock：两次机会</li>
</ul>
<p><strong>系统颠簸</strong></p>
<p>内存没有足够帧，进程忙于交换页，此时CPU利用率极低。</p>
<hr />
<h2 id="file-system">File system</h2>
<p><strong>文件系统</strong></p>
<ul>
<li>
<p>存大量数据</p>
</li>
<li>
<p>进程停止后数据能保存</p>
</li>
<li>
<p>多个进程可以并发访问</p>
</li>
</ul>
<p><strong>文件系统架构（自上而下）</strong></p>
<table>
<thead>
<tr>
<th>层级</th>
<th>操作、实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>App, Programs</td>
<td>发出文件请求的代码</td>
</tr>
<tr>
<td>Logical File System</td>
<td>OS最高层。保护、安全、文件名解析</td>
</tr>
<tr>
<td>File-organization Module</td>
<td>逻辑块</td>
</tr>
<tr>
<td>Basic File System</td>
<td>具体文件块</td>
</tr>
<tr>
<td>I/O Control</td>
<td>驱动、中断</td>
</tr>
<tr>
<td>Devices</td>
<td>Disk,tapes</td>
</tr>
</tbody>
</table>
<p><strong>分配磁盘块方法</strong></p>
<ul>
<li>Contiguous allocation 连续分配</li>
<li>Linked allocation 链接分配</li>
<li>Indexed allocation 索引分配</li>
</ul>
<p><strong>空闲空间管理</strong></p>
<ul>
<li>
<p>空闲表法</p>
</li>
<li>
<p>Bit vector 位示图法</p>
</li>
<li>
<p>Linked list 空闲链表法</p>
</li>
</ul>
<hr />
<h2 id="io-system">I/O System</h2>
<p><strong>I/O Device</strong></p>
<ul>
<li>Block devices 块设备：由于信息的存取总是以数据块为单位的，所以存储信息的设备称为块设备，如硬盘，每个都有自己的地址，可寻址。</li>
<li>Character devices 字符设备：用于数据输入输出的设备为字符设备，因为其传输的基本单位是字符，如打印机，不可寻址。</li>
</ul>
<p><strong>I/O software layers</strong></p>
<ul>
<li>中断处理</li>
<li>设备驱动</li>
<li>设备无关的I/O软件</li>
</ul>
<p><strong>Kernel I/O Subsystem</strong></p>
<ul>
<li>Scheduling</li>
<li>Buffering 缓冲，在设备传输时存数据，解决设备速度不一致。</li>
<li>Caching 缓存，快速存储数据备份。</li>
<li>Spooling，保存设备输出。</li>
</ul>
<hr />
<h2 id="disk">Disk 磁盘</h2>
<p><strong>磁盘结构</strong></p>
<p>磁盘物理地址：&lt;磁头号，磁道号，扇区号&gt;</p>
<p><strong>访问时间</strong></p>
<p>访问时间有两部分：1、<strong>Seek time</strong> 磁头寻道时间。2、Rotational latency 磁盘转到合适位置需要的时间。</p>
<p><strong>磁盘调度算法</strong></p>
<p><strong>FCFS</strong>：遵循先来先服务原则。</p>
<p><strong>SSTF</strong>：最短寻道时间优先  离磁头当前位置最近的优先。</p>
<p><strong>SCAN </strong>：先按一个方向移动至边界，再换另一个方向移动。</p>
<p><strong>C-SCAN</strong>：先向一个方向移动至边界，直接到磁盘开始位置，再按同一方向移动。</p>
<p><strong>LOOk</strong>：先按一个方向移动，到最远请求为止，再换另一个方向移动。</p>
<p><strong>C-LOOK</strong>：先向一个方向移动，回来到最远的访问点，再按同一方向移动。</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../computer-network/" class="btn btn-neutral float-right" title="知识笔记-计算机网络-基础概念">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../datastructure-algorithm/tree/" class="btn btn-neutral" title="数据结构-树"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/ydlan/mkdocs-notes/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../datastructure-algorithm/tree/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../computer-network/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../js/extra.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
      <script src="../../search/main.js" defer></script>

</body>
</html>
