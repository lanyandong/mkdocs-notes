# 操作系统核心要点

## 线程锁

**互斥锁**

互斥锁是用于多线程多任务对共享资源互斥访问的一个信号量。也就是说，当一个线程占用了某个资源，那么别的线程就无法访问，知道这个线程unlock，其他的线程才开始可以利用这个资源。当然互斥锁不一定是锁定某个资源，还可以是进行一些计算或者数据处理之类。互斥锁必须是谁上锁就由谁来解锁，且要么被锁住，要么被解开。互斥锁(互斥量)强调的是资源的互斥访问，要区别于进程线程同步常用的信号量。

**读写锁**

读写锁与互斥锁类似，不过读写锁允许更高的并行性。互斥量要么是锁住状态要么是不加锁状态，而且一次只有一个线程可以对其加锁。读写锁可以由三种状态：`读模式下加锁状态、写模式下加锁状态、不加锁状态`。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。读写锁非常适合于对数据结构读的次数远大于写的情况，也常用于数据库管理中，称作共享-互斥锁（S-X锁），符合两阶段封锁原则。

虽然读写锁提高了并行性，但是就速度而言并不比互斥量快，根据这两种锁的特性可以知道，在一些写操作比较多或是本身需要同步的地方并不多的程序中我们应该经历使用互斥量，而在读操作远大于写操作的一些程序中我们应该使用读写锁来进行同步。

**条件锁**

条件锁就是所谓的条件变量；条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。一旦条件满足就以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为任务队列为空这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。这个过程中就使用到了条件变量pthread_cond_t。

**自旋锁**

自旋锁是一种busy-waiting的锁。也就是说，如果T1正在使用自旋锁，而T2也去申请这个自旋锁，此时T2肯定得不到这个自旋锁。与互斥锁不同的是，这时当T2需要等待的时候并不是睡眠等待唤醒，而是不停的循环检测T1是否已经释放了锁，这样做的好处是节省了线程从睡眠状态到唤醒之间内核会产生的消耗，在加锁时间短暂的环境下这点会提高很大效率。

**递归锁**：

严格上讲递归锁只是互斥锁的一个特例，同样只能有一个线程访问该对象，但允许同一个线程在未释放其拥有的锁时反复对该锁进行加锁操作； windows下的临界区默认是支持递归锁的，而linux下的互斥量则需要设置参数PTHREAD_MUTEX_RECURSIVE_NP，默认则是不支持。





****

## 死锁的条件及解决的办法

**死锁的条件**

必须同时存在以下的四个条件才能发生死锁。

1.互斥条件   
即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。

2.不可抢占条件。  
进程所获得的资源在未使用完毕之前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源的占有者进程自行释放。

3.占有且申请条件。   
进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。

4.循环等待条件   
存在一个进程等待序列{P1，P2，...，Pn}，其中P1等待P2所占有的某一资源，P2等待P3所占有的某一源，......，而Pn等待P1所占有的的某一资源，形成一个进程循环等待环。



**死锁的预防**

死锁的预防是保证系统不进入死锁状态的一种策略。

1.破坏互斥条件。         

2.破坏不可抢占条件。   
可抢占式，即要求申请失败的进程释放自己占有的资源给别人用，降低系统性能。

3.破坏占有且申请条件。   
直接申请自己所需要的所有资源。--1.不可预知自己需要什么资源  2.资源利用率低，长期占有自己可能不用的资源。

4.破坏循环等待条件   
资源分类、编号，按序申请。 --·1.编号可能是困难的，维护相应的序列是困难的



**死锁的避免**

死锁的避免指的是不限制进程有关申请资源的命令，而是对进程所发出的每一个申请资源命令加以动态地检查，并根据检查结果决定是否进行资源分配。
银行家算法。当一个进程申请使用资源的时候，银行家算法通过先 试探 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。

判定安全状态需要已分配资源、还需要的资源、可用资源、finish判定符。



****

## 进程和线程有什么异同

**进程**：进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。

**线程**：线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。

1. 进程是资源分配的最小单位，线程是程序执行的最小单位。
2. 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
3. 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
4. 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。



****

## 虚拟内存是怎么实现的？

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。



****

## 进程调度算法

**FCFS(First Come First Server，先来先服务)**  
这是最简单，最基本的算法，它的思想非常简单，就是按照进程到来的时间顺序，逐个分配 CPU 资源



**SJF(Short Job First，短作业优先)**  
从后备队列中选择运行时间最短的进程进行服务    
缺点：

- 必须知道作业的运行时间，在采用这种算法时，要先知道每个作业运行时间。即使是程序员也很难估计作业的运行时间，如果估计过低，系统就可能按照估计的时间终止作业的运行，但此时作业并没有完成，故一般都会偏长估计。
- 对长作业非常不利，长作业的周转时间会明显的增长。
- 该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能够得到及时处理。

**PSA(优先级调度)**   
按照进程的优先级选择调度顺序

**RR (时间片轮转算法)**  
为 CPU 的执行设定一个时间片大小，每个进程轮询分配时间片，时间片结束后暂停运行加入等待队列。

**多级反馈队列调度算法**  
将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转。优点是兼顾长短作业，有较好的响应时间，可行性强，适用于各种作业环境。

**高响应比优先调度算法**  
根据“响应比=（进程执行时间+进程等待时间）/ 进程执行时间”这个公式得到的响应比来进行调度。高响应比优先算法在等待时间相同的情况下，作业执行的时间越短，响应比越高，满足段任务优先，同时响应比会随着等待时间增加而变大，优先级会提高，能够避免饥饿现象。优点是兼顾长短作业，缺点是计算响应比开销大，适用于批处理系统。



****

## 操作系统的内存管理



