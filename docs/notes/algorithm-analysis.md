### 时间复杂度

**大O表示法**

一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为**T(n)**，它是该算法问题规模n的函数，时间复杂度主要分析T(n)的数量级。

算法中基本运算（最深层循环内的语句）的频度与T(n)同数量级，因此通常采用算法中基本运算的频度**f(n)**来分析算法的时间复杂度。因此，算法的时间复杂度记为$T(n)=O(f(n))​$

O的含义是T(n)的数量级，其严格的数学定义是：若T(n)和f(n)是定义在正整数集合上的两个函数，则存在正常数C和$n_0$，使得当$n\geqslant n_0$时，都满足$0\leqslant T(n)\leqslant Cf(n)$.

可以总结为: **T(n)增长率小于等于f(n)**

**除此之外的表示法**

- $T(n)=\Omega(g(n))$  T(n)增长率大于等于g(n)
- $T(n)=\Theta(b(n))$  T(n)增长率等于b(n)
- $T(n)=o(p(n))$  T(n)增长率小于p(n)      

一般总是考虑最坏时间复杂度，以保证算法的运行时间不会比它更长。

**加法规则**：$T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))​$

**乘法规则**：$T(n)=T_1(n)\times T_2(n)=O(f(n))\times O(g(n))=O(f(n)\times g(n))​$

**常见的时间复杂度**：$O(1)<O(\log_2 n)<O(n)<O(n\log_2 n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)$





****

### 空间复杂度

算法的空间复杂度S(n)定义为该算法所耗费的存储空间，它是问题规模n的函数。记为$S(n)=O(g(n))​$



****

### 排序算法

**相关概念**

* 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
* 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
* 内排序：所有排序操作都在内存中完成；
* 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；

**排序算法分类**

![sort](https://s2.ax1x.com/2019/08/01/eaOj56.png)



[注]：冒泡排序、插入排序、归并排序和基数排序是稳定的排序算法；选择排序、快速排序、希尔排序、堆排序是不稳定的排序算法。



**排序算法总结**

说明：<font color=darkblue>n: 数据规模，k: “桶”的个数，In-place: 占用常数内存，不占用额外内存，Out-place: 占用额外内存。</font>

![sort](https://s2.ax1x.com/2019/08/01/eaOxPK.png)



**排序算法实现**

![wait](../img/wait.jpeg)

